# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_simulation.ipynb (unless otherwise specified).

__all__ = ['Simulation', 'Simulation_Honda']

# Cell
import torch, numpy as np

# Cell
class Simulation(object):
    '''Abstract class for vertex dynamics simulations

    Children should implement following methods:
    - `energy(self,...)`: calculates systems energy
    - `force(self,...)` : calculates forces acting on all vertices
    (you can implement either one, or both of the energy and force functions)
    - `sample_trajectory(self,...)`: simulates dynamics and samples vertex trajectories.
    This method should use either force or energy (spatial gradient) to simulate the system dynamics.
    '''
    def __init__(self,m=None):
        '''m: `Monolayer` or `Graph` object (e.g. cells defined as polygons).'''
        pass
    def energy(self):
        '''Computes the total free energy of the system.'''
        pass
    def force(self):
        '''Computes the total force acting on each vertex. Alternatively use F_i = -grad_i(U), where
        grad_i is the spatial gradient with respect to vertex i, and U is the total free energy.
        '''
        pass
    def sample_trajectory(self, T=10000, delta_T=0.001, sample_freq=10, T_ignore=500):
        '''
        Run simulation for `T` time steps and sample vertex trajectories with frequency `sample_freq`.
        - `T`  : total number of time steps
        - `delta_T`: step size (e.g. for the numerical integration using Euler's method)
        - `sample_freq`: Trajectory sampling frequency. Use `assert (T % sample_freq == 0)` in your implementation.
        - `T_ignore`: number of initial time steps to ignore.
        '''
        pass

# Cell
class Simulation_Honda(Simulation):
    '''Honda et al. definition of Vertex model. This approach defines a phenomenological total free energy
    (_or_ work function) of the `Monolayer`: `U = Ud + Us + Ua`
    - `Ud` : deformation energy or elastic energy of the cells. For a cell `k`, `Ud[k] = K*(A[k] - A0)^2`
    where `A[k]>=0` is an area of cell `k`, `K>=0` is an elastic constant, and `A0>=0` is a target area.
    - `Us` : membrane surface tension energy. For cell `k`, `Us[k] = Kp*(P[k] - P0)^2`
    where `Kp>=0` is a constant, `P0` is a target perimeter (constant), and `P[k]` is a perimeter of cell `k`.
    - `Ua` : cell-cell adhesion energy, overall energy of adhesion and contractile tensions along
    cell-cell junctions. `Ua = sum_edges[ Lambda_ij(t)*l_ij ]`, where `Lambda_ij(t)` is a time-dependent value,
    or a constant value, and `l_ij` is edge length between cells `i` and `j`. This (time-dependent) parameter
    can be used to represent active tensions in the simulation.

    References:
    - Fletcher A.G., _et al._, _Progress in Biophysics and Molecular Biology_ __113__, 299-326 (2013).
    '''
    def __init__(self, m=None,params={'Ka':1., 'A0':2.3, 'Kp':0.01,'P0':0., 'Lambda_ij':lambda m,t: 1.}):
        '''
        - `m` : `Monolayer` object (`Graph` w/ cells defined as polygons).
        - `params` : simulation parameters for the vertex model. `params` must be a dictionary with following keys,
            * 'Ka' - "elastic" area constant(s),
            * 'A0' - target cell area(s),
            * 'Kp' - "elastic" perimeter constant(s),
            * 'P0' - target cell perimeter(s) {default: 0},
            * 'Lambda_ij' - a function `f(m,t)`, 'Lambda_ij' must accept the cell monolayer (`self.m`) and the simulation time
            (t=number_of_iters * delta_T) and return a constant (float) or a torch tensor. Size and type of the tensor must be
            the same size and type as the edge lengths tensor computed by the monolayer's `m.length()` method.
        '''
        super().__init__()
        self.m = m # cell monolayer
        self.params = params # simulation parameters

    def energy(self,t):
        '''Computes total free energy U: `U = Ud + Us + Ua`, U is a function of sim-n parameters (`params`), monolayer ('m'),
        and time (used for implementing periodic contractions through `params['Lambda_ij']` function).
        '''
        Ka, A0 = self.params['Ka'], self.params['A0']
        Kp, P0 = self.params['Kp'], self.params['P0']
        Lij = self.params['Lambda_ij'](self.m, t)
        E_tot = torch.sum( Ka*( ( self.m.area() - A0)**2)) + \
        torch.sum( Kp*( ( self.m.perimeter() - P0)**2)) + torch.sum(Lij*self.m.length())
        return E_tot

    def sample_trajectory(self, T=10000, delta_T=0.001, sample_freq=10, T_ignore=500):
        '''
        Run simulation for `T` time steps and sample vertex trajectories with frequency `sample_freq`.
        - `T`  : total number of time steps
        - `delta_T`: step size (e.g. for the numerical integration using Euler's method)
        - `sample_freq`: Trajectory sampling frequency. Use `assert (T % sample_freq == 0)` in your implementation.
        - `T_ignore`: number of initial time steps to ignore.
        '''
        assert (T % sample_freq == 0)
        self.m.vertices.requires_grad_(True)


#     @property
#     def x(self):
#         return self._x
#     @x.setter
#     def x(self, val):
#         self._x = val