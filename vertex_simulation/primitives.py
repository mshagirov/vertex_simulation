#AUTOGENERATED! DO NOT EDIT! File to edit: dev/00_primitives.ipynb (unless otherwise specified).

__all__ = ['plot_graph', 'VoronoiRegions2Edges', 'Vertex', 'Graph', 'Monolayer']

#Cell
import torch
import numpy as np, matplotlib.pylab as plt

#Cell
def plot_graph(Xv,edges,plot_arg=['g-','mo'],alphas=[.2,.5]):
    '''Simple function for plotting vertices(location `Xv`) and `edges`'''
    for ij in edges:
        plt.plot([Xv[ij[0],0], Xv[ij[1],0]], [Xv[ij[0],1], Xv[ij[1],1]],plot_arg[0],lw=2,alpha=alphas[0])
    plt.plot(Xv[:,0],Xv[:,1],plot_arg[-1],ms=10,alpha=alphas[-1])
    plt.axis('equal')
    plt.axis(False);

#Cell
def VoronoiRegions2Edges(regions):
    '''Converts Voronoi region vertex indices, like the one obtained from `scipy.spatial.Voronoi`,
    to a list of (*undirected*) edges (indices of vertex pairs).

    Edges [i,j] and [j,i] are considered to be the same edge, and stored as one of these
    representations e.g. [j,i], but not both (i.e. no duplicate edges). Note that edge indexing in
    `cells` starts from 1 (not 0!). Thus, when reading cell edges from `edge_list` you need to
    substract 1 from (absolute value of) these indices.

    Usage:
    - `edge_list,cells = VoronoiRegions2Edges(vrn_regions)`

    Arg-s:
    - `regions` is a list of lists, empty regions, or regions with out-of-diagram vertices ("-1") are ignored

    Returns:
    - `edge_list` : list of edges of an undirected graph.
    - `cells`: dictionary of cells (Voronoi regions), keys: cell numbers, values: list of
    **edge indices starting from 1**. Negative indices indicate reversed order for vertices
    (together these edges form a closed region--a cell). Use `np.sign(cells[c])` to find reversed edges.
    '''
    def is_in_edges_(e,edge_list):
        '''Returns edge index in the list, "-" means in reversed order, False if not found'''
        if (e in edge_list):
            return edge_list.index(e)+1
        elif ((e[1],e[0]) in edge_list):
            return -(1+edge_list.index((e[1],e[0])))
        else:
            return False

    edge_list = []
    cells = {}
    cell_k = 0
    for r in regions:
        if len(r)==0 or (-1 in r ):
            continue # ignore empty regions or those with vertex index -1
        cells[cell_k] = []
        for e in zip(r[-1:]+r[:-1],r):
            edge_idx = is_in_edges_(e,edge_list)
            if edge_idx:
                cells[cell_k].append(edge_idx)
            else:
                cells[cell_k].append(len(edge_list)+1)
                edge_list.append(e)
        cell_k+=1
    return edge_list,cells

#Cell
class Vertex(object):
    '''Implements vertex and stores vertex position(s) as Nx2 (or any 2-D tensor) `torch.Tensor`:(x,y,...)'s.
    Rows represent points, columns the spatial dimensions, i.e. `[[x1,y1], [x2,y2], ...,[xN,yN]]`

    - Methods:
        - `dist(self,other)` : calculates Euclidean distance between two points (each row).
        - `zero_grad_(self)` : set all gradients to zero (used during gradient descent at each iter-n step).
        - `grad(self)` : get gradient w.r.t. each tensor in `self.x`
        - `requires_grad_(self,val)`: sets `torch.tensor` flag inplace
        - `requires_grad(self)`: returns `torch.tensor` flag
    - Properties :
        - `x` : use it to set/get location torch.tensor (returns or modifies self.x)
    '''
    def __init__(self,location=None,**kwargs):
        '''`location` must be a 2D `torch.tensor` w/ float dtype (or a compatible list of lists,
        and numpy.ndarray). Set and get `location` with `self.x` property.

        Important note on setting `requires_grad` flag. If the given `location` is a `numpy.ndarray`
        keyword arg-s are ingnored (uses `torch.from_numpy()`). In such cases, use `self.requires_grad_(True)`
        after the initialization to set the flag inplace.

        Usage:
        `v = Vertex(torch.tensor([[3.,-1.]],requires_grad=True,dtype=torch.float64))`
        '''
        if location is not None:
            if type(location) is list:
                location = torch.tensor(location,**kwargs)
            elif type(location) is np.ndarray:
                location = torch.from_numpy(location)
            assert location.ndim==2, f"Input 'location' has wrong dimensions, location.ndim!=2 :'( "
        self._x=location

    def dist(self,other):
        ''' Calculate (Euclidean) distance to another vertex from self._x.'''
        return torch.norm(other.x - self._x,dim=1,p=2,keepdim=True)

    def zero_grad_(self):
        '''set gradients to zero if x.requires_grad==True'''
        if self._x.grad is not None:
            self._x.grad.data.zero_()

    def grad(self):
        '''Get accumulated gradients w.r.t. x (calculated with backprop; `torch.autograd`)'''
        return self._x.grad

    def requires_grad_(self,val):
        '''Access to `torch.tensor` method to change `requires_grad` status'''
        self._x.requires_grad_(val)

    def requires_grad(self):
        '''Access to `torch.tensor` method to view `requires_grad` status'''
        return self._x.requires_grad

    def device(self):
        """Returns torch tensor's device"""
        return self.x.device
    def to_(self,val):
        """Change torch tensor's device"""
        self._x = self.x.to(val)

    def dtype(self):
        """Returns torch tensor's dtype"""
        return self.x.dtype

    @property
    def x(self):
        return self._x
    @x.setter
    def x(self, val):
        self._x = val

    def __str__(self):
        return f"{self._x}"
    def __repr__(self):
        return f"Vertex {self._x}; dtype:{self._x.dtype}"


#Cell
class Graph(object):
    '''Implements graph object. Stores vertices and edges.
    - Methods:
        - `length(self)` : calculates (Euclidean) edge lengths for each edge in the graph.
        - `direction(self)`: calculates edge vectors (`second_vertex - first_vertex` positions)
        - `get_vertex_grad(self)`: returns accumulated gradients w.r.t. to vertex positions.
        - `set_zero_grad_(self)`: sets gradients w.r.t. to vertex positions to zeros.
    - Properties :
        - `vertices` : variable vertices represented by `Vertex` object (needs autograd).
        - `edges` : edges connecting vertices.Nx2 array of integers (vertex indices).
        Can be any `torch.tensor` compatible array with `tolist()` method (doesn't need autograd).
        - `fixed`: [__not yet implemented__] stores information about constant/fixed vertices (for setting boundary).
        Provided for convenience, turn off gradient calculation separately from "variable" vertices to keep them constant.
        '''
    def __init__(self,vertices=None, edges=None, fixed=None):
        '''Init-n function for `Graph` objects. Stores vertices and edges.

        Usage:
            `g = Graph(edges=torch.tensor([[0,1],[1,2],[2,0]]), vertices=Vertex(torch.tensor([[1,1],[0,-1],[-1,0]]))`
        '''
        self._vertices = vertices
        self._edges = edges
        self._fixed= fixed

    def length(self):
        ''' Calculates all edge lengths in the graph.
        Lengths--(Euclidean) distances between vertex pairs connected with edges.
        Order of the lengths is same as the order of the edges, i.e. i'th result corresponds to i'th edge.
        '''
        return torch.norm(self.vertices.x[self.edges[:,1],:] - self.vertices.x[self.edges[:,0],:],
                          dim=1,p=2,keepdim=True)

    def direction(self):
        '''Calculates edge vector (direction) from first vertex to its pair connected with an edge.'''
        return self.vertices.x[self.edges[:,1],:] - self.vertices.x[self.edges[:,0],:]

    def get_vertex_grad(self):
        '''Get accumulated gradients w.r.t. vertex positions (`self.vertices.x`) (calculated with backprop; `torch.autograd`)'''
        return self.vertices.grad()

    def set_zero_grad_(self):
        '''Set gradients to zero if `requires_grad` is set to `True` for variable vertices. Uses `vertices.zero_grad_()`'''
        self.vertices.zero_grad_()

    @property
    def edges(self):
        return self._edges
    @edges.setter
    def edges(self,val):
        self._edges = val

    @property
    def vertices(self):
        return self._vertices
    @vertices.setter
    def vertices(self, val):
        self._vertices = val

    @property
    def fixed(self):
        return self._fixed
    @fixed.setter
    def fixed(self, val):
        self._fixed = val

    def __str__(self):
        if (self.edges is None) or (self.vertices is None):
            return f"Graph: edges {self._edges}; vertices {self.vertices}"
        dtype_edges = self.edges.dtype
        dtype_verts = self.vertices.dtype()
        return f"Graph\nedges {self._edges} {dtype_edges};\nvertices {self.vertices} {dtype_verts}"
    def __repr__(self):
        n_edges = self.edges if self.edges is None else self.edges.size(0)
        n_verts = self.vertices if self.vertices is None else self.vertices.x.size(0)
        return f"Graph: {n_edges} edges; {n_verts} vertices"


#Cell
class Monolayer(Graph):
    '''Implements 2-dimensional cell monolayer (apical plane) represented by vertices and edges.

    - to-do:
        - add cell area calculation method
    '''
    def __init__(self, vertices=None, edges=None, cells=None, fixed=None):
        '''Usage:
        - cells = Monolayer(edges=torch.tensor([[0,1],[1,2],[2,0]]), vertices=Vertex([[1.,1.],[0.,-1.],[-1.,0.]]))
        '''
        super().__init__(vertices=vertices, edges=edges, fixed=fixed)

        # cells must be a dict (keys:cell#,values:edge indices w/ negative indices for reverced edge direction)
        self._cells = cells

    def perimeter(self):
        '''Calculates perimeters of the cells'''
        if (self.cells is None) or len(self.cells)==0:
            return torch.zeros((1,))
        Perims = []
        for c in self.cells:
            c_edges = self.edges[np.abs(self.cells[c])-1,:]
            Perims.append(torch.sum(torch.norm(
                self.vertices.x[c_edges[:,1],:] - self.vertices.x[c_edges[:,0],:],
                dim=1,p=2,keepdim=True),0,keepdim=True))
        return torch.cat(Perims,dim=0)

    def area(self):
        '''Calculates areas of the cells. Defined only for simple 2D polygons ("shoelace formula")'''
        if (self.cells is None) or len(self.cells)==0:
            return torch.zeros((1,))
        Areas = []
        for c in self.cells:
            # compute area of each cell
            c_edges = self.edges[np.abs(self.cells[c])-1,:]
            if np.any(np.sign(self.cells[c])<0):
                # reverse vertex order for negative edges
                tmp = c_edges[np.sign(self.cells[c])<0,:]
                c_edges[np.sign(self.cells[c])<0,0]=tmp[:,1]
                c_edges[np.sign(self.cells[c])<0,1]=tmp[:,0]
            xy = self.vertices.x[c_edges[:,0],:]
            Areas.append(torch.abs(
                torch.sum(xy[:-1,0]*xy[1:,1],0,keepdim=True) + xy[-1,0]*xy[0,1]
                -torch.sum(xy[1:,0]*xy[:-1,1],0,keepdim=True) - xy[0,0]*xy[-1,1] )/2 )

        return torch.cat(Areas,dim=0)

    @property
    def cells(self):
        return self._cells
    @cells.setter
    def cells(self, val):
        self._cells = val

    def __str__(self):
        n_cells = self.cells if self.cells is None else len(self.cells)
        return f"Monolayer {n_cells} cells\n{self.cells};\n{super().__str__()}"
    def __repr__(self):
        n_cells = self.cells if self.cells is None else len(self.cells)
        return f"Monolayer {n_cells} cells, {super().__repr__()}"