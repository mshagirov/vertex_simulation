#AUTOGENERATED! DO NOT EDIT! File to edit: dev/00_primitives.ipynb (unless otherwise specified).

__all__ = ['Vertex', 'Graph', 'Monolayer']

#Cell
import torch
import numpy as np

#Cell
class Vertex(object):
    '''Implements vertex and stores vertex position(s) as Nx2 (or any 2-D tensor) `torch.Tensor`:(x,y,...)'s.
    Rows represent points, columns the spatial dimensions, i.e. `[[x1,y1], [x2,y2], ...,[xN,yN]]`

    - Methods:
        - `dist(self,other)` : calculates Euclidean distance between two points (each row).
        - `zero_grad_(self)` : set all gradients to zero (used during gradient descent at each iter-n step).
        - `grad(self)` : get gradient w.r.t. each tensor in `self.x`
        - `requires_grad_(self,val)`: sets `torch.tensor` flag inplace
        - `requires_grad(self)`: returns `torch.tensor` flag
    - Properties :
        - `x` : use it to set/get location torch.tensor (returns or modifies self._x)
    '''
    def __init__(self,location=None,**kwargs):
        '''`location` must be (or convertible to)  2D `torch.tensor` w/ float dtype, set and get `location` with self.x

        Usage:
        `v = Vertex(torch.tensor([[3.,-1.]],requires_grad=True,dtype=torch.float64))`
        '''
        if location is not None:
            if type(location) is list:
                location = torch.tensor(location,**kwargs)
            elif type(location) is np.ndarray:
                location = torch.from_numpy(location)
            assert location.ndim==2, f"Input 'location' has wrong dimensions, location.ndim!=2 :'( "
        self._x=location

    def dist(self,other):
        ''' Calculate (Euclidean) distance to another vertex from self._x.'''
        return torch.norm(other.x - self._x,dim=1,p=2,keepdim=True)

    def zero_grad_(self):
        '''set gradients to zero if x.requires_grad==True'''
        if self._x.grad is not None:
            self._x.grad.data.zero_()

    def grad(self):
        '''Get accumulated gradients w.r.t. x (calculated with backprop; `torch.autograd`)'''
        return self._x.grad

    def requires_grad_(self,val):
        '''Access to `torch.tensor` method to change `requires_grad` status'''
        self._x.requires_grad_(val)

    def requires_grad(self):
        '''Access to `torch.tensor` method to view `requires_grad` status'''
        return self._x.requires_grad

    @property
    def x(self):
        return self._x
    @x.setter
    def x(self, val):
        self._x = val

    def __str__(self):
        return f"{self._x}"
    def __repr__(self):
        return f"Vertex {self._x}; dtype:{self._x.dtype}"


#Cell
class Graph(object):
    '''Implements graph object. Stores vertices and edges.
    - Methods:
        - `length(self)` : calculates (Euclidean) edge lengths for each edge in the graph.
        - `direction(self)`: calculates edge vectors (`second_vertex - first_vertex` positions)
        - `get_vertex_grad(self)`: returns accumulated gradients w.r.t. to vertex positions.
        - `set_zero_grad_(self)`: sets gradients w.r.t. to vertex positions to zeros.
    - Properties :
        - `edges` : edges connecting vertices.Nx2 array of integers (vertex indices).
        Can be any `torch.tensor` compatible array with `tolist()` method (doesn't need autograd).
        - `vertices` : variable vertices represented by `Vertex` object (needs autograd).
        - `fixed`: [__not yet implemented__] stores information about constant/fixed vertices (for setting boundary).
        Provided for convenience, turn off gradient calculation separately from "variable" vertices to keep them constant.
        '''
    def __init__(self,edges=None,vertices=None,fixed=None):
        '''Init-n function for `Graph` objects. Stores vertices and edges.

        Usage:
            `g = Graph(edges=torch.tensor([[0,1],[1,2],[2,0]]), vertices=Vertex(torch.tensor([[1,1],[0,-1],[-1,0]]))`
        '''
        self._edges = edges
        self._vertices = vertices
        self._fixed= fixed

    def length(self):
        ''' Calculates all edge lengths in the graph. Lengths--(Euclidean) distances between vertex pairs connected with edges.'''
        return torch.norm(self.vertices.x[self.edges[:,1],:] - self.vertices.x[self.edges[:,0],:],
                          dim=1,p=2,keepdim=True)

    def direction(self):
        '''Calculates edge vector (direction) from first vertex to its pair connected with an edge.'''
        return self.vertices.x[self.edges[:,1],:] - self.vertices.x[self.edges[:,0],:]

    def get_vertex_grad(self):
        '''Get accumulated gradients w.r.t. vertex positions (`self.vertices.x`) (calculated with backprop; `torch.autograd`)'''
        return self.vertices.grad()

    def set_zero_grad_(self):
        '''Set gradients to zero if `requires_grad` is set to `True` for variable vertices. Uses `vertices.zero_grad_()`'''
        self.vertices.zero_grad_()

    @property
    def edges(self):
        return self._edges
    @edges.setter
    def edges(self,val):
        self._edges = val

    @property
    def vertices(self):
        return self._vertices
    @vertices.setter
    def vertices(self, val):
        self._vertices = val

    @property
    def fixed(self):
        return self._fixed
    @fixed.setter
    def fixed(self, val):
        self._fixed = val

    def __str__(self):
        if (self.edges is None) or (self.vertices is None):
            return f"Graph: edges {self._edges}; vertices {self.vertices}"
        return f"{self._edges.tolist()}"
    def __repr__(self):
        if (self.edges is None) or (self.vertices is None):
            return f"Graph\nedges {self._edges}"
        return f"Graph\nedges {self.edges};dtype:{self.edges.dtype}\nvertices {self.vertices}"


#Cell
class Monolayer(Graph):
    '''Implements 2-dimensional cell monolayer (apical plane) represented by vertices and edges.

    - to-do:
        - add graph of edges or list of neighbouring edges (i.e. adjacency matrix entries for edges)
        - add cells, perimeter and area calculation
    '''
    def __init__(self,edges=None,vertices=None,fixed=None):
        '''Usage:
        - cells = Monolayer()
        '''
        super().__init__(edges=edges,vertices=vertices,fixed=fixed)

    def __str__(self):
        return f"Monolayer edges {super().__str__()}"
    def __repr__(self):
        return f"Monolayer {super().__repr__()}"