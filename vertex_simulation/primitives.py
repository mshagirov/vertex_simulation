#AUTOGENERATED! DO NOT EDIT! File to edit: dev/00_primitives.ipynb (unless otherwise specified).

__all__ = ['Vertex', 'Graph']

#Cell
import torch
import numpy as np

#Cell
class Vertex(object):
    '''Implements vertex and stores vertex position(s) as Nx2 (or any 2-D tensor) `torch.Tensor`:(x,y,...)'s.
    Rows represent points, columns the spatial dimensions, i.e. `[[x1,y1], [x2,y2], ...,[xN,yN]]`

    - Methods:
        - `dist(self,other)` : calculates Euclidean distance between two points (each row).
        - `zero_grad_(self)` : set all gradients to zero (used during gradient descent at each iter-n step).
        - `grad(self)` : get gradient w.r.t. each tensor in `self.x`
    - Properties :
        - `x` : use it to set/get location torch.tensor (returns or modifies self._x)
    '''
    def __init__(self,location=None,**kwargs):
        '''`location` must be (or convertible to)  2D `torch.tensor` w/ float dtype, set and get `location` with self.x

        Usage:
        `v = Vertex(torch.tensor([[3.,-1.]],requires_grad=True,dtype=torch.float64))`
        '''
        if location is not None:
            if type(location) is list:
                location = torch.tensor(location,**kwargs)
            elif type(location) is np.ndarray:
                location = torch.from_numpy(location)
            assert location.ndim==2, f"Input 'location' has wrong dimensions, location.ndim!=2 :'( "
        self._x=location

    def dist(self,other):
        ''' Calculate (Euclidean) distance to another vertex from self._x.'''
        return torch.norm(other.x - self._x,dim=1,p=2,keepdim=True)

    def zero_grad_(self):
        '''set gradients to zero if x.requires_grad==True'''
        if self._x.grad is not None:
            self._x.grad.data.zero_()

    def grad(self):
        '''Get accumulated gradients w.r.t. x (calculated with backprop; `torch.autograd`)'''
        return self._x.grad

    @property
    def x(self):
        return self._x
    @x.setter
    def x(self, val):
        self._x = val

    def __str__(self):
        return f"{self._x}"
    def __repr__(self):
        return f"Vertex {self._x}; dtype:{self._x.dtype}"


#Cell
class Graph(object):
    '''Implements graph object. Stores vertices and edges.

    - Methods:
        - `length(self)` : calculates (Euclidean) edge lengths for each edge in the graph.
        - `direction(self)`: calculates edge vectors (`second_vertex - first_vertex` positions)
        - `get_vertex_grad(self)`: returns accumulated gradients w.r.t. to vertex positions.
        - `set_zero_grad_(self)`: sets gradients w.r.t. to vertex positions to zeros.
    - Properties :
        - `edges` : edges connecting vertices. Nx2 array of integers (vertex indices).
        - `vertices` : variable vertices represented by `Vertex` object.
        - `fixed`: constant (fixed boundary) vertices represented by `Vertex` object.
        Provided for convenience, turn off gradient calculation separately from "variable" vertices to keep them constant.
        '''
    def __init__(self,edges=None,vertices=None,fixed=None):
        '''Init-n function for `Graph` objects. Stores vertices and edges.

        Usage:
            `g = Graph(edges=torch.tensor([[0,1],[1,2],[2,0]]), vertices=Vertex(torch.tensor([[1,1],[0,-1],[-1,0]]))`
        '''
        self._edges = edges
        self._vertices = vertices
        self._fixed= fixed

    def length(self):
        ''' Calculates edge lengths-- (Euclidean) distances between vertex pairs connected with a given edge.'''
        return torch.norm(self.vertices.x[self.edges[:,1],:] - self.vertices.x[self.edges[:,0],:],
                          dim=1,p=2,keepdim=True)

    def direction(self):
        '''Calculates edge vector (direction) from first vertex to its pair connected with an edge.'''
        return self.vertices.x[self.edges[:,1],:] - self.vertices.x[self.edges[:,0],:]

    def get_vertex_grad(self):
        '''Get accumulated gradients w.r.t. vertex positions (`self.vertices.x`) (calculated with backprop; `torch.autograd`)'''
        return self.vertices.grad()

    def set_zero_grad_(self):
        '''Set gradients to zero if `requires_grad` is set to `True` for variable vertices. Uses `vertices.zero_grad_()`'''
        self.vertices.zero_grad_()

    @property
    def edges(self):
        return self._edges
    @edges.setter
    def edges(self,val):
        self._edges = val

    @property
    def vertices(self):
        return self._vertices
    @vertices.setter
    def vertices(self, val):
        self._vertices = val

    def __str__(self):
        return f"{self._edges.tolist()}"
    def __repr__(self):
        return f"Graph\nedges {self._edges}; dtype:{self._edges.dtype}\nvertices {self._vertices}"
